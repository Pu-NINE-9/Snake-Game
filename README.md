# Pygame 贪吃蛇游戏
Hello，大家好呀~我是NINE~ Long time no see~
这是一款基于AI Coding完成的、使用 Python 和 Pygame 库开发的经典贪吃蛇游戏，具有人机对战模式、动态得分系统、多种道具和响应式UI等现代化功能。

## 主要特性

- **两种游戏模式**:
  - **人机对战**: 玩家与一个由AI控制的对手进行比赛。
  - **网络对战**: (开发中) 为未来的在线多人游戏预留的占位符。
- **动态计分系统**:
  - 玩家和AI的初始分数均为100分。
  - 吃到食物的一方加10分，另一方减10分。
  - 任何一方分数归零则游戏结束。
- **加速道具**:
  - 游戏过程中会随机出现黄色加速道具。
  - 吃到道具的蛇会在5秒内速度提升，增加游戏变数。
- **响应式用户界面**:
  - 游戏窗口会根据用户的屏幕分辨率自动调整大小，确保在不同设备上都有一致的视觉体验。
- **丰富的游戏控制**:
  - **暂停/继续**: 游戏中随时可以按 `P` 键或点击“暂停”按钮来暂停和继续游戏。
  - **退出游戏**: 在暂停菜单或游戏结束界面，可以选择退出到主菜单。
  - **重新开始**: 游戏结束后，可以立即重新开始一局新游戏。
- **明确的视觉指示**:
  - 屏幕左下角清晰标注了玩家、AI和食物的代表颜色。
  - 游戏结束时会明确显示胜利方。
- **流畅的操作体验**:
  - 采用基于时间的移动更新机制，确保蛇的移动平滑，按键响应迅速，无卡顿感。

## 如何游戏

1.  **启动游戏**: 运行 `main.py` 文件或可执行程序。
2.  **菜单选择**:
    - 使用**鼠标点击**或**上下箭头键**来选择菜单项。
    - 按**回车键**或**点击**确认选择。
    - 可选择“人机对战”或“退出游戏”。
3.  **人机对战模式**:
    - **玩家 (绿色)**: 使用**上、下、左、右箭头键**来控制你的蛇。
    - **AI (蓝色)**: AI会自动追踪食物。
    - **目标**: 尽可能多地吃食物（红色方块），避免撞到墙壁、自己或对方的蛇。

## 项目结构

```
.
├── main.py         # 游戏主入口
├── menu.py         # 游戏菜单界面
├── game.py         # 核心游戏逻辑
├── README.md       # 项目说明文件
└── icon.ico        # 应用图标
```

- **`main.py`**: 游戏的入口文件。它负责初始化Pygame，获取屏幕尺寸，并创建和运行 `Menu` 类的实例。
- **`menu.py`**: 定义了 `Menu` 类，负责处理主菜单的显示和交互逻辑，包括模式选择和退出功能。
- **`game.py`**: 包含了游戏的所有核心逻辑和元素，如 `Snake`, `Food`, `PowerUp`, `Button`, 和 `Game` 类。

## 核心代码实现逻辑

### `main.py`

作为程序的起点，`main.py` 的主要职责是：
1.  初始化 Pygame 库。
2.  使用 `pygame.display.Info()` 获取当前用户的屏幕分辨率。
3.  将获取到的屏幕宽度和高度传递给 `Menu` 类的构造函数，以实现UI的响应式设计。
4.  实例化 `Menu` 并调用其 `run()` 方法，启动游戏菜单。

### `menu.py`

`Menu` 类管理着游戏开始前的所有交互：
- **初始化**: 接收 `main.py` 传来的屏幕尺寸，并据此设置窗口、字体大小和菜单项的位置。
- **菜单选项**: 创建包括“人机对战”、“网络对战”（占位符）和“退出”在内的多个选项。
- **事件处理**:
  - **键盘**: 监听上下箭头键以切换选中项，监听回车键以确认选择。
  - **鼠标**: 实现 `check_hover` 来检测鼠标悬停，并通过 `is_clicked` 处理点击事件，提供了更现代化的交互方式。
- **启动游戏**: 当选择“人机对战”时，它会实例化 `Game` 类，并将屏幕尺寸传递过去，从而启动游戏。

### `game.py`

这是项目中最复杂的文件，定义了游戏世界中的所有对象和规则。

- **`Button` 类**: 一个可复用的UI组件，用于在屏幕上创建可交互的按钮。它能处理绘制、鼠标悬停效果和点击检测，被广泛用于暂停、退出、重新开始等功能。

- **`Snake` 类**:
  - **属性**: 包含蛇的身体（坐标列表）、颜色、当前方向和速度。
  - **`move()`**: 更新蛇头的位置并移除蛇尾，实现移动。
  - **`grow()`**: 在蛇头方向增加一节身体，用于吃掉食物后的增长。

- **`Food` 和 `PowerUp` 类**:
  - 结构相似，都负责在屏幕的随机位置生成一个物体（食物或道具）。
  - 包含一个 `draw()` 方法，用于在屏幕上将自己绘制出来。

- **`Game` 类**: 游戏的大脑，协调所有部分。
  - **初始化 (`__init__`)**: 设置屏幕、时钟、字体，并创建所有游戏内按钮和对象实例。
  - **游戏状态管理**:
    - `paused`: 布尔值，用于控制游戏的暂停和继续。
    - `game_over_state`: 布尔值，用于判断游戏是否结束。
  - **核心循环 (`run`)**:
    - **时间控制**: `self.clock.tick(60)` 将游戏循环的最高帧率限制在60 FPS。通过 `delta_time` 实现基于时间的移动，彻底解决了输入延迟和卡顿问题。蛇的移动速度由 `player_move_timer` 和 `speed` 属性共同决定，与帧率解耦。
    - **事件处理**: 监听键盘（P键暂停，Q键退出）和鼠标点击（针对UI按钮）。
    - **碰撞检测 (`check_collisions`)**: 精确检测蛇头是否与边界、自身身体或对方身体发生碰撞。一旦碰撞，游戏立即结束。
  - **UI绘制**:
    - `draw_scores()`: 在屏幕顶部显示双方分数。
    - `draw_legend()`: 在左下角绘制颜色图例。
  - **重置与结束**:
    - `reset_game()`: 用于重新开始游戏，将所有状态（分数、蛇的位置和长度等）恢复到初始值。
    - `game_over_screen()`: 在游戏结束时调用，显示胜利者，并提供“重新开始”和“返回首页”的选项。